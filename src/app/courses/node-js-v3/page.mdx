import { CourseLayout } from "@/components/CourseLayout";

export const course = {
  title: "Introduction to Node.js, v3",
  imageUrl: "/courses/node-js-v3.webp",
  date: "2023-08-13",
  author: {
    name: "Scott Moss",
    imageUrl: "/authors/ScottMoss.webp",
  },
  description:
    "用Node.js将你的JavaScript技能拓展到服务器端！学习构建命令行界面、读写文件和数据库，以及创建可扩展的服务器。使用第三方模块、异步编码和CRUD操作。用Jest测试你的代码。掌握开发专业Node.js应用所需的全部技能！",
};

export const metadata = {
  title: course.title,
};

export default (props) => <CourseLayout course={course} {...props} />;

# 0-introduction

- **课程讲师**: Scott Moss
  - 拥有超过 15 年经验的软件工程师，现为投资者。
  - 曾就职于 Netflix 并为其他公司提供咨询。
  - 对 Node.js 充满热情，视其为自己的“母语”。
- **课程概述**:
  - 本课程为 "Intro to Node.js V3"。
  - 将涵盖 Node.js 最新版本的变化以及新的开发方法。
  - 强调了 Node.js 在现代前端开发中的重要性，几乎所有前端工作都离不开它。
  - 课程笔记是供学员参考的工具，教学风格以实时编码和实例演示为主。
- **课程项目**:
  - 我们将构建一个笔记应用程序。
  - 该应用包含两个主要部分：
    1. 一个**命令行界面 (CLI)**，用于在终端中管理笔记。
    2. 一个**网站组件**，用于在网页上查看这些笔记。
  - 通过这个项目，我们将学习 Node.js 的核心概念，包括：
    - 模块 (Modules) 和 NPM
    - 命令行界面 (CLIs)
    - 服务器 (Servers)
    - 文件系统交互
- **学习目标**:
  - 为学员打下坚实的 Node.js 基础。
  - 理解 Node.js 是什么、如何使用它及其功能。
  - 帮助来自其他语言（如 PHP）的开发者建立与 Node.js 的可比性认知。
  - 虽然是入门课程，但欢迎提出更深入的问题。
- **课程资源**:
  - **GitHub 仓库**: 提供已完成项目的代码，可用于参考或追赶进度。
    - 注意：现场编写的代码可能与仓库中的版本不完全一致。
  - **重要链接**:
    - NPM (Node Package Manager) 官网。
    - Node.js 官方文档。

# 1-history-of-node-js

- **什么是 Node.js？**
  - 它是一个让你可以在**浏览器之外**运行 JavaScript 的**运行时环境**。
  - 在 Node.js 出现之前，JavaScript 只能在浏览器中运行，被认为是一种“小儿科”的语言。
  - 由 Ryan Dahl 创建，他将 Google Chrome 的 V8 JavaScript 引擎移植到了计算机上，使其成为一个独立的运行环境。
- **与浏览器 JavaScript 的主要区别**
  - **运行环境**: Node.js 直接在操作系统上运行，而浏览器 JS 在浏览器环境中运行。
  - **可用的 API**:
    - Node.js 没有浏览器特有的 API，如 **DOM** (文档对象模型) 或 **CSS**。
    - 相反，它提供了与计算机交互的 API，例如文件系统（`fs`）、网络（`http`）等。
  - **语言 vs. 运行时**:
    - **语言本身仍然是 JavaScript**。如果你了解 JavaScript，你就已经掌握了大约 90% 的 Node.js。
    - 区别在于“运行时”提供的不同能力和全局变量。
- **发展历史与演变**
  - **诞生于 2009 年**。
  - 曾因版本更新停滞（在 v0.12 左右），导致社区分裂并创建了一个名为 `IO.js` 的分支。
  - `IO.js` 的出现促使 Node.js 核心团队重组并加快了开发步伐。
  - 如今，Node.js 拥有一个正式的管理委员会，紧跟 ECMAScript 标准，并定期发布新版本。
  - 本课程将使用 **Node.js v18**。
- **现代应用场景**
  - 广泛用于生产环境，构建各种应用，如：
    - Web 服务器
    - 代理服务器
    - **构建工具**
  - 在现代前端开发中至关重要。几乎所有的前端框架（React, Vue 等）都依赖 Node.js 作为其构建工具（例如，使用 Webpack 或 Vite 将 JSX 转换为浏览器可读的 JavaScript）。
  - Node.js 已成为现代 Web 开发不可或缺的一部分。

# 2-non-blocking-i-o

- **核心概念: 非阻塞 I/O (Non-Blocking I/O)**
  - **I/O**: 指输入/输出操作，例如读取文件、发起网络请求、查询数据库等。
  - **阻塞 (Blocking / Synchronous)**: 在许多传统语言中（如 Ruby, Python），当程序执行一个 I/O 操作时，它会“阻塞”或暂停，直到该操作完成后才能继续执行下一行代码。若要并行处理，通常需要创建和管理多个线程。
  - **非阻塞 (Non-Blocking / Asynchronous)**: Node.js 采用单线程、非阻塞模型。当发起一个 I/O 操作时，程序不会等待其完成，而是继续执行后续代码。当该 I/O 操作完成后，会通过一个回调函数来通知你结果。
- **事件循环 (Event Loop)**
  - 这是实现非阻塞 I/O 的核心机制。
  - 可以将其想象成一个“待办事项”的注册表和调度中心。
  - 当一个异步操作开始时，它被交给系统底层处理。
  - 事件循环会不断检查是否有已完成的操作。
  - 当一个操作完成时，其对应的**回调函数**会被放入一个队列中。当主调用栈为空时，事件循环会从队列中取出回调函数并执行它。
  - 这个模型使得 Node.js 能够用一个线程高效地处理大量并发请求。
- **性能特点**
  - **优点**: 非常适合 I/O 密集型应用（如 Web 服务器、API 网关），因为它可以用很少的资源处理大量并发连接。
  - **缺点**: 不适合 **CPU 密集型**任务（如人工智能、机器学习、复杂计算），因为它默认只使用单个 CPU 核心。这类任务通常首选 Python 等语言。
- **代码示例**

  - **阻塞代码 (同步)**:

    - 代码从上到下按顺序执行。
    - `lookup` 函数会“阻塞”执行，直到返回结果。

    ```jsx
    function getUserSync(id) {
      const lookup = // ... a quick, blocking database lookup
      return lookup;
    }

    const user = getUserSync(1);
    // do something with user...
    // 这行代码必须等待 getUserSync 完成

    ```

  - **非阻塞代码 (异步)**:

    - `setTimeout` 模拟了一个耗时的 I/O 操作。
    - 程序在调用 `getUserAsync` 后会立即执行后面的代码，而不会等待 1 秒。
    - 1 秒后，回调函数才会被事件循环执行。

    ```jsx
    function getUserAsync(id, callback) {
      setTimeout(() => {
        const user = { id: id };
        callback(user); // 任务完成后，执行回调
      }, 1000);
    }

    getUserAsync(1, (user) => {
      // 这个函数里的代码会稍后执行
      console.log(user);
    });

    // 这行代码会先于上面的 console.log(user) 执行
    console.log("Request sent!");
    ```

- **问与答**
  - **问**: 浏览器里的 JavaScript 事件循环和 Node.js 的事件循环有区别吗？
  - **答**: 概念上是相同的。底层的实现细节不同，因为它们运行在不同的环境里（浏览器 vs. 操作系统），但作为开发者，你感知到的工作方式和行为模式基本一致。
  - **问**: “如果你懂 JS，就懂 90% 的 Node” 这句话能再解释一下吗？
  - **答**: 因为 Node.js 使用的编程语言就是 JavaScript。语法、数据类型、函数等核心语言特性是完全一样的。那 10% 的区别在于**运行时环境**提供的特定 API，例如 Node.js 提供了文件系统 (`fs`) 模块，而浏览器提供了文档对象模型 (`document`)。

# 3-hello-world

- **安装 Node.js**

  - **推荐方法: NVM (Node Version Manager)**
    - 它是一个工具，可以让你在同一台电脑上安装和管理**多个 Node.js 版本**，并轻松切换。
    - 可以通过其 GitHub 页面上的脚本来安装。
    - 安装后，需要根据提示将 NVM 的配置添加到你的 shell 配置文件中 (如 `.zshrc`, `.bash_profile` 等)。
    - 使用 `nvm install 18` 来安装 Node.js 的 18 版本。
  - **备选方法: 官方安装包**
    - 访问 [nodejs.org](https://nodejs.org/) 官网。
    - 下载 **LTS (Long-Term Support)** 版本，这是长期支持版，更稳定。
    - 这种方法安装简单，但版本切换不便，且有时会遇到文件权限问题。
  - **验证安装**

    - 安装完成后，在终端运行以下命令来检查版本：

    ```bash
    node --version

    ```

- **编写你的第一个 Node.js 程序**

  1. 创建一个新文件夹作为项目目录。
  2. 在文件夹中创建一个新文件，例如 `index.js`。
  3. 在 `index.js` 中写入一些你熟悉的 JavaScript 代码：

     ```jsx
     console.log("hello world");
     ```

  4. 打开终端，进入到该项目目录，然后运行以下命令：

     ```bash
     node index.js

     ```

  5. 你将会在终端看到输出 `hello world`。

- **关键概念**
  - **执行**: `node <文件名>` 是使用 Node.js 运行时来执行一个 JavaScript 文件的命令。
  - **`console.log()`**:
    - 在 Node.js 中，`console.log` 的作用与浏览器中类似。
    - 不同之处在于，它的输出目标是**终端 (Terminal)**，而不是浏览器的开发者控制台。
    - 它等同于其他操作系统级别语言中的 `print` 或 `puts`。
- **环境差异示例**
  - Node.js 环境中没有浏览器特有的全局 API。
  - 如果你尝试在 Node.js 中使用 `alert()`，程序会报错。
  - **示例代码**:
    ```jsx
    alert("This will not work");
    ```
  - **运行结果**:
    - `ReferenceError: alert is not defined`
  - 这清晰地表明，尽管语言都是 JavaScript，但 Node.js 和浏览器是两个不同的**运行时环境**，它们提供的可用 API 是不同的。

# 4-browser-vs-node-js

- **全局对象 (Global Objects)**
  - **浏览器**: 顶层的全局对象是 `window`。所有全局变量和函数都附加在它上面 (例如 `alert()` 实际上是 `window.alert()`)。
  - **Node.js**: 顶层的全局对象是 `global`。
    - 你可以通过 `console.log(global)` 来查看它的内容。
    - 它包含了一些与浏览器共有的全局函数，如 `setTimeout`, `setInterval`，以及 Node.js 特有的对象。
    - 在 Node.js 中使用 `window` 会导致 `ReferenceError: window is not defined` 的错误。
- **模块系统 (Modules)**
  - 现在浏览器和 Node.js 都支持标准的 ES 模块 (`import`/`export`)。
  - **浏览器**: 通常通过 `<script type="module" src="..."></script>` 标签来加载模块。
  - **Node.js**: 直接在 JavaScript 文件中使用 `import` 和 `export` 语法。因为没有 DOM，所以不存在 `<script>` 标签。
- **DOM (Document Object Model)**
  - **Node.js 中完全没有 DOM**。
  - 像 `document.getElementById`、`document.querySelector` 这样的 API 是不可用的。
  - 虽然 Node.js 服务器可以生成 HTML 字符串，但它本身不渲染页面，也无法操作页面上的元素。DOM 操作只能在浏览器环境中由客户端 JavaScript 执行。
- **服务器 (Server) vs. 客户端 (Client)**
  - **Node.js**: 主要用于创建**服务器**。服务器是一个持续运行的程序，它监听网络请求，并返回响应（如数据、HTML 文件等）。
  - **浏览器中的 JS**: 通常扮演**客户端**的角色，负责向服务器发送请求，并处理从服务器接收到的响应。
- **Node.js REPL**

  - **REPL** 是 **R**ead, **E**valuate, **P**rint, **L**oop (读取、求值、打印、循环) 的缩写。
  - 它是一个交互式的命令行环境，可以让你即时编写和执行 JavaScript 代码。
  - **如何启动**: 在终端里直接输入 `node` 命令，然后按回车。

    ```bash
    $ node
    Welcome to Node.js v18.14.0.
    Type ".help" for more information.
    > const a = 10;
    undefined
    > a + 5
    15
    >

    ```

  - **用途**:
    - 适合快速测试小段代码。
    - 进行简单的计算。
    - 验证某个 API 的行为。
    - 不适合用来编写完整的应用程序，因为代码不会被保存。
  - **如何退出**:
    - 连续按两次 `Ctrl+C`。
    - 或者输入 `.exit` 并按回车。

# 5-process-environment

- **构建 CLI (命令行界面)**
  - CLI (Command Line Interface) 是在终端中运行的应用程序，例如我们常用的 `git`, `ls`, `npm` 等。
  - 本课程的项目就是一个笔记管理 CLI。
- **`process` 全局对象**
  - 这是 Node.js 提供的一个强大的全局对象，无需 `require` 即可使用。
  - 它提供了有关当前 Node.js **进程**的信息和控制功能。
  - 它是连接你的代码与操作系统的桥梁，允许你的程序根据运行环境动态调整行为。
- **`process.argv` (命令行参数)**

  - `argv` (Argument Vector) 是一个数组，包含了启动 Node.js 进程时传递的所有命令行参数。
  - 这是为 CLI 应用获取用户输入的关键。
  - **结构分析**:
    - `process.argv[0]`: 总是 Node.js 可执行文件的路径。
    - `process.argv[1]`: 总是当前执行的脚本文件的路径。
    - `process.argv[2]` 及以后: 用户传入的实际参数。
  - **示例**: 运行命令 `node index.js hello world`
    ```jsx
    console.log(process.argv);
    ```
  - **输出**:

    ```
    [
      '/usr/local/bin/node',          // [0] Node 可执行文件
      '/path/to/project/index.js',    // [1] 脚本文件
      'hello',                        // [2] 第一个参数
      'world'                         // [3] 第二个参数
    ]

    ```

- **`process.env` (环境变量)**
  - 这是一个包含了所有用户**环境变量**的对象。
  - 这是在应用程序中访问敏感信息（如 API 密钥、数据库密码）和配置项的标准方式。
  - **为什么重要**: 它允许你将**配置和代码分离**。绝不能将密钥等敏感信息硬编码在代码中，而应通过环境变量注入。
  - **常见约定: `NODE_ENV`**
    - 这是一个广泛使用的环境变量，用于标识应用的运行模式，常见的值有：
      - `development` (开发环境)
      - `production` (生产环境)
      - `test` (测试环境)
    - 代码可以根据 `NODE_ENV` 的值来改变行为。
    - **示例**:
      - 在 `development` 模式下开启详细的日志记录。
      - 在 `production` 模式下关闭调试功能，并启用性能优化。
      - 像 React 这样的框架会利用它来决定是否显示警告信息或优化渲染。
- **问与答**
  - **问**: 分享 `.env` (环境变量文件) 的最佳实践是什么？
  - **答**: 这是一个复杂的安全问题，没有单一的完美答案，但关键原则是**绝不将 `.env` 文件提交到 Git 等版本控制系统**。常见的做法包括：
    - **使用密钥管理服务**：如 HashiCorp Vault, AWS Secrets Manager 等，通过 API 安全地获取密钥。
    - **使用加密的密码管理器**：如 1Password, LastPass，在团队成员之间安全地共享凭据。
    - **本地开发**：每个开发者在自己的机器上维护一份本地的 `.env` 文件，里面是各自的开发环境配置。

# 6-custom-cli-setup

- **什么是 CLI？**
  - **CLI (Command Line Interface)**: 在终端中运行的应用程序。
  - 它可以由任何能在操作系统上运行的语言编写（如 Go, Rust, Python, Node.js）。
  - 用户在使用 CLI 时，无需关心它是用什么语言构建的。
- **步骤 1: 初始化 Node.js 项目**

  - 要创建一个正式的 Node.js 项目，你需要一个 `package.json` 文件来管理项目元数据和依赖。
  - 在你的项目根目录下运行以下命令：

    ```bash
    npm init

    ```

  - 你可以一路按回车接受默认值，或使用 `npm init -y` 快速生成。
  - 这会创建一个 `package.json` 文件。

- **步骤 2: 在 `package.json` 中定义 CLI 命令**
  - 为了让 Node.js 知道你的项目提供了一个可执行的命令，需要在 `package.json` 中添加一个 `bin` 字段。
  - `bin` 是一个对象，其中：
    - **键 (key)** 是你希望用户在终端中输入的**命令名称** (例如 `note`)。
    - **值 (value)** 是当该命令被调用时，应该执行的**脚本文件路径**。
  - **示例**:
    ```json
    // package.json
    {
      "name": "my-notes-cli",
      "version": "1.0.0",
      "description": "A simple note-taking CLI",
      "main": "index.js",
      "bin": {
        "note": "./index.js"
      }
      // ... 其他字段
    }
    ```
- **步骤 3: 本地链接 CLI 命令**

  - 在开发阶段，为了能方便地测试你的 CLI 命令，而不需要每次修改后都重新发布和安装，你可以使用 `npm link`。
  - 这个命令会在你的系统中创建一个**符号链接 (symlink)**，将你在 `bin` 字段中定义的命令（如 `note`）链接到你当前的项目目录。
  - 在项目根目录下运行：

    ```bash
    npm link

    ```

  - 现在，你在任何地方运行 `note` 命令，都会执行你项目中的 `index.js` 文件。你对代码的任何修改都会立即生效。

- **步骤 4: 添加 Hashbang (Shebang)**

  - 当你运行 `note` 命令时，你的操作系统需要知道用哪个**解释器 (interpreter)** 来运行 `index.js` 文件（是 Bash, Python, 还是 Node?）。
  - 你必须在你的可执行脚本文件 (`index.js`) 的**第一行**添加一个特殊的注释，称为 **Hashbang**。
  - **示例**:

    ```jsx
    #!/usr/bin/env node

    console.log("My CLI is working!");
    ```

  - `#!` 是 Hashbang 的标志。
  - `/usr/bin/env node` 是一个标准的、可移植性强的写法，它告诉操作系统在当前用户的环境变量路径中查找 `node` 可执行程序，并用它来运行此脚本。
  - 添加此行后，你的 `note` 命令就应该可以正确执行了。

# 7-processing-cli-arguments

- **目标: 处理来自命令行的用户输入**
  - 我们希望能够从命令行捕获用户输入的文本，并用它来创建一条新笔记。
  - **理想的命令格式**: `note "这是一条新的笔记"`
- **获取命令行参数**
  - 我们可以使用 `process.argv` 来访问传递给 CLI 的参数。
  - 记住，用户输入的参数是从数组的**索引 `2`** 开始的。
  - **为何需要引号?**: 如果不使用引号将 `这是一条新的笔记` 包裹起来，shell 会将每个词（被空格分开）视为一个独立的参数。引号确保整个句子被当作一个单独的字符串参数。
- **创建简单的数据模型**

  - 我们将创建一个 JavaScript 对象来表示一条笔记。
  - 这个对象将包含从命令行获取的内容以及一个唯一的 ID。

    ```jsx
    #!/usr/bin/env node

    // 从命令行参数的第 3 项 (索引为 2) 获取笔记内容
    const noteContent = process.argv[2];

    // 创建一个新的笔记对象
    const newNote = {
      content: noteContent,
      id: Date.now(), // 使用当前时间戳作为简单的唯一 ID
    };

    // 打印新创建的笔记对象，以验证它是否工作正常
    console.log(newNote);
    ```

- **运行 CLI 并查看结果**

  - **命令**:

    ```bash
    note "我的第一条笔记"

    ```

  - **预期输出** (ID 会不同):
    ```json
    { "content": "我的第一条笔记", "id": 1678886400000 }
    ```

- **当前方法的局限性**
  - **1. 缺乏持久化 (Persistence)**:
    - 笔记只在程序运行时存在于内存中。程序执行完毕后，这条笔记就消失了。
    - 我们需要一种方法来**保存**笔记，以便将来可以再次读取它们。
  - **2. 功能单一**:
    - 目前的实现只能创建笔记。
    - 无法实现列出所有笔记、搜索、删除或编辑等更复杂的功能。
  - **3. 参数解析简陋**:
    - 手动解析 `process.argv` 数组非常繁琐且容易出错。
    - 当需要处理更复杂的命令（如带有标志 `-tag` 或选项 `t`）时，这种方法会变得难以管理。
- **后续步骤**
  - 我们将引入 Node.js 的内置模块和第三方库来解决这些问题：
    - 实现数据的**持久化**（保存到文件）。
    - 使用专门的库来**简化命令行参数的解析**。

# 8-modules-overview

- **什么是模块 (Module)？**
  - 核心目的：**代码隔离**与**封装**。
  - 将代码封装在自己的作用域内，避免污染全局作用域，使其像可复用的“乐高积木”。
  - 历史上的做法是使用 **IIFE** (立即调用函数表达式) 来模拟模块，以保护代码不被其他脚本干扰。
- **Node.js 中的模块类型**
  1. **内置模块 (Internal Modules)**: Node.js 核心自带的模块，如 `http` (网络)、`fs` (文件系统)。
  2. **用户创建的模块 (User-created Modules)**: 我们自己在项目中创建的文件，用于组织和拆分代码。这些模块也可以发布到社区供他人使用。
  3. **第三方模块 (Third-party Modules)**: 由其他开发者创建并发布到 npm 等平台的模块，我们可以下载并在项目中使用。
- **模块系统：CommonJS vs. ES Modules**
  - **CommonJS (CJS)**: Node.js 最初的、传统的模块系统。
    - 使用 `require()` 导入模块。
    - 使用 `module.exports` 导出模块。
    - 示例: `const fs = require('fs');`
  - **ES Modules (ESM)**: ECMAScript 官方标准化的模块系统，也是现代前端开发的主流。
    - 使用 `import` 导入模块。
    - 使用 `export` 导出模块。
    - 这是本课程将使用的系统。
- **如何在 Node.js 中启用 ES Modules**

  - 在项目的 `package.json` 文件中，添加一个顶级字段：

    ```json
    "type": "module"

    ```

  - 这个设置会告诉 Node.js 将项目中的 `.js` 文件默认当作 ES 模块来处理。

- **创建和使用模块 (ESM 语法)**
  - **导出 (Export)**:
    - **命名导出 (Named Export)**: 导出时带有特定名称。
      ```jsx
      // utils.js
      export function add(a, b) {
        return a + b;
      }
      ```
    - **默认导出 (Default Export)**: 每个文件只能有一个默认导出。
      ```jsx
      // utils.js
      export default {
        // ... some object or value
      };
      ```
  - **导入 (Import)**:
    - **导入命名导出**: 必须使用 `{}` 并且名称要完全匹配。
      ```jsx
      import { add } from "./utils.js";
      ```
    - **导入默认导出**: 可以使用任意名称，且无需 `{}`。
      ```jsx
      import myUtils from "./utils.js";
      ```
  - **重要提示：文件扩展名**
    - 在 Node.js 中使用 ES 模块时，导入本地文件**必须包含文件扩展名** (`.js`)。
    - 示例: `import { count } from './utils.js';` (正确) vs `import { count } from './utils';` (错误)。
    - 这与许多前端构建工具（如 React）的行为不同，但在 Node.js 中是强制要求，因为它需要明确知道要加载的文件类型。

# 9-importing-exporting-modules

- **导入模块的三种方式**

  1. **导入自定义模块 (本地文件)**: 路径必须是相对或绝对路径，通常以 `./` 或 `../` 开头。

     ```jsx
     import { count } from "./utils.js";
     ```

  2. **导入核心模块 (Node.js 内置)**: 直接使用模块名，Node.js 会知道这是内置模块。

     ```jsx
     import fs from "fs";
     ```

     - **新式语法 (推荐)**: 使用 `node:` 前缀可以明确表示这是一个核心模块，避免与第三方包同名冲突。
       ```jsx
       import fs from "node:fs";
       ```

  3. **导入第三方模块 (来自 `node_modules`)**: 直接使用包名，Node.js 会在 `node_modules` 文件夹中查找。

     ```jsx
     import lodash from "lodash";
     ```

- **`require` vs. `import` (CommonJS vs. ESM) 语法对比**

  - 了解 CommonJS 仍然很重要，因为大量现有的 Node.js 项目还在使用它。
  - **导入 (Importing)**
    - **ESM**:
      ```jsx
      import fs from "fs";
      import { count } from "./utils.js";
      ```
    - **CommonJS**:
      ```jsx
      const fs = require("fs");
      const { count } = require("./utils.js");
      ```
  - **导出 (Exporting)**

    - **ESM**:
      ```jsx
      // 命名导出
      export function count() {
        /* ... */
      }
      // 默认导出
      export default { count };
      ```
    - **CommonJS**:

      ```jsx
      // 类似于命名导出
      exports.count = function () {
        /* ... */
      };

      // 类似于默认导出 (更常见)
      module.exports = { count };
      ```

- **历史与演进**
  - CommonJS 是在 JavaScript 语言本身没有标准化模块系统时，由 Node.js 社区创建的解决方案。
  - ES Modules (ESM) 是后来 TC39 委员会为 JavaScript 语言制定的官方标准。
  - Node.js 正在逐步转向并原生支持 ESM，使其成为未来的标准实践。
- **模块依赖图 (Dependency Graph)**
  - 你的应用程序是由一系列 `import` 和 `export` 语句连接起来的模块组成的。这形成了一个依赖树或图。
  - Node.js 会自动处理这个图，包括解析复杂的循环依赖关系（例如，文件 A 导入 B，B 导入 C，C 又导入 A）。

# 10-thinking-in-modules

- **模块化思考的核心原则**
  - **保持文件小而专注**: 每个模块应该只做好一件事。将相关的逻辑功能组织在一起。
  - **不要吝啬创建模块**: 在 Node.js 中，创建新文件（模块）的成本几乎为零。这不像在浏览器中，更多的文件意味着更多的网络请求。
  - **模块化的好处**:
    1. **易于测试**: 小而独立的模块更容易进行单元测试。
    2. **减少合并冲突**: 在团队协作中，如果不同的人在不同的文件（模块）中工作，代码合并冲突的概率会大大降低。
    3. **代码复用和可维护性**: 组织良好的模块更容易被复用和理解。
- **组织模块的两种常见模式**
  1. **按功能组织 (Group by feature)**: 将所有与特定功能相关的代码放在一个模块中。例如，所有与用户处理相关的函数都放在 `user.js` 中。
  2. **按类型组织 (Group by type)**: 将所有相似类型的函数放在一起。例如，将所有通用的辅助函数，即使它们彼此无关，也放在一个 `utils.js` 文件中。
- **`index.js` 模式**

  - 这是一种非常强大的组织模式，用于从一个目录中统一导出多个模块。
  - **工作方式**:

    1. 创建一个文件夹，例如 `components`。
    2. 在该文件夹内，创建多个独立的模块文件，如 `button.js`, `input.js`。
    3. 在 `components` 文件夹的根目录下，创建一个名为 `index.js` 的文件。
    4. 这个 `index.js` 文件作为该目录的“公共出口”，它导入并重新导出其他所有模块。

       ```jsx
       // components/index.js
       export * from "./button.js";
       export * from "./input.js";
       ```

    5. 现在，从其他地方导入时，你可以直接从文件夹导入，Node.js 会自动查找 `index.js`。

       ```jsx
       // app.js
       import { Button, Input } from "./components";
       ```

  - **优点**: 使导入路径更简洁，并将一个目录的内部结构细节隐藏起来，只暴露其公共 API。

- **最佳实践: `import` vs. `require`**
  - **强烈推荐使用 `import` (ESM)**。
  - **原因**:
    1. **与前端保持一致**: 现代前端开发生态（React, Vue 等）完全基于 ES Modules。在后端也使用 `import` 可以为全栈开发提供统一、流畅的体验。
    2. **面向未来**: ES Modules 是 JavaScript 的官方标准。未来 Node.js 很可能会将其作为默认模块系统，不再需要 `"type": "module"` 的配置。

# 11-internal-3rd-party-modules

- **有用的内置模块 (Internal Modules)**
  - **`fs` (File System)**: 用于与计算机的文件系统进行交互。可以读/写文件、创建/删除目录等。非常强大，是构建工具（如`create-react-app`）生成项目文件的基础。
  - **`http`**: 用于创建 HTTP 服务器和处理网络请求。它相对底层，通常开发者会使用基于它构建的框架（如 Express.js）。
  - **`path`**: 用于处理和转换文件路径，在不同操作系统之间提供了一致性。
- **`npm` (Node Package Manager) 和第三方模块**

  - `npm` 是 Node.js 的默认包管理器，用于安装和管理外部依赖。
  - **安装一个包**:

    ```bash
    npm install <package-name>
    # 简写
    npm i <package-name>

    ```

  - **安装后会发生什么**:
    1. **`node_modules` 文件夹被创建**: 这个文件夹包含了你安装的包以及其所有依赖项的代码。**永远不要将 `node_modules` 提交到版本控制系统（如 Git）**。
    2. **`package.json` 文件被更新**: `dependencies` 字段会添加新安装的包及其版本范围。
    3. **`package-lock.json` 文件被创建/更新**:
       - 这是一个至关重要的文件，它记录了 `node_modules` 目录中**每个包的精确版本**。
       - **作用**: 确保团队中的每个成员以及部署服务器安装的都是完全相同的依赖版本，从而避免“在我电脑上能跑”的问题。

- **团队协作与部署流程**
  - 开发者将 `package.json` 和 `package-lock.json` 提交到 Git。
  - 其他人拉取代码后，在本地终端运行 `npm install`。
  - `npm` 会读取 `package-lock.json` 文件，并精确地下载所有指定的依赖项到 `node_modules` 文件夹中。
- **NPM 包的安全性**
  - 的确存在风险，可能会有恶意或损坏的包。
  - **一些检查方法**:
    - 查看包的 GitHub 仓库：检查更新频率、issue 数量和社区活跃度。
    - 检查每周下载量。
    - 大公司通常会有内部的包白名单。
  - 实际上，遇到**年久失修或已损坏**的包的概率远大于遇到**恶意**包的概率。
- **卸载一个包**

  ```bash
  npm uninstall <package-name>

  ```

  - 这个命令会从 `node_modules`、`package.json` 和 `package-lock.json` 中移除该包。

# 12-using-the-yargs-module

- **问题: 手动解析 CLI 参数太麻烦**
  - 直接处理 `process.argv` 数组来构建一个功能丰富的命令行界面（CLI）是非常繁琐且容易出错的。
- **解决方案: 使用第三方库**
  - 我们将使用一个流行的库 **`yargs`** 来帮助我们构建交互式命令行工具。它能轻松地解析参数并自动生成优雅的用户界面（如帮助菜单）。
- **安装 `yargs`**

  ```bash
  npm install yargs

  ```

- **重构项目结构**

  - 为了保持代码整洁，我们进行以下调整：

    1. **入口文件 (`index.js`) 保持最小化**: 它的唯一职责是导入并执行应用的主逻辑。
    2. **创建 `src` 目录**: 用来存放所有核心应用代码。
    3. **移动 CLI 逻辑**: 将所有 `yargs` 相关的代码移动到一个新文件，例如 `src/commands.js`。
    4. **更新 `index.js`**:

       ```jsx
       #!/usr/bin/env node
       import "./src/commands.js";
       ```

    - 这样，`index.js` 就成为了一个清晰的程序入口，而所有复杂的逻辑都被封装在 `src` 目录中。

- **`yargs` 的基本用法**

  - **`hideBin(process.argv)`**: 这是一个辅助函数，用于从 `process.argv` 数组中移除前两个元素（node 执行路径和脚本路径），只留下用户真正输入的参数。
  - **`.command()`**: 用于定义一个 CLI 命令。例如 `npm` 的 `install` 就是一个命令。
  - **`.demandCommand(1)`**: 要求用户至少输入一个命令，否则 `yargs` 会报错并显示帮助信息。
  - **`.parse()`**: 启动 `yargs` 的解析过程。
  - **示例代码** (`src/commands.js`):

    ```jsx
    import yargs from "yargs";
    import { hideBin } from "yargs/helpers";

    yargs(hideBin(process.argv))
      .command(
        "curl <url>",
        "抓取一个 URL 的内容",
        () => {},
        (argv) => {
          console.log(argv); // argv 是一个解析后的对象，而不是原始数组
        }
      )
      .demandCommand(1)
      .parse();
    ```

- **`yargs` 带来的好处**
  - **参数对象化**: `yargs` 将命令行参数解析成一个方便使用的对象，而不是让你手动处理数组。
  - **自动生成帮助菜单**: `yargs` 能根据你的命令定义，自动生成一个标准的帮助菜单。用户可以通过 `note --help` 来查看所有可用的命令和选项。这是 CLI 工具的一个通用标准，而我们无需编写任何代码即可获得。

# 13-notes-app-commands

- **目标: 使用 `yargs` 搭建笔记应用的命令结构**
  - 我们将定义应用所需的所有命令，但暂时只搭建框架，不实现具体逻辑。
- **`yargs` 的 `.command()` 方法详解**
  - 该方法用于定义一个新命令，其参数结构如下：
    `.command(command, description, [builder], [handler])`
  1. **`command` (字符串)**: 定义命令的格式。
     - `new <note>`: `new` 是命令名, `<note>` 是**必需的**位置参数。
     - `find [query]`: `[query]` 是**可选的**位置参数。
  2. **`description` (字符串)**: 命令的描述，会显示在帮助菜单中。
  3. **`builder` (对象或函数)**: 用于配置该命令的特定选项（flags）。
     - `yargs.positional()`: 详细配置位置参数（如类型、描述）。
     - `yargs.option()`: 定义命名选项，如 `-tags`。
  4. **`handler` (函数)**: 当用户执行该命令时，此函数会被调用。它接收一个包含所有解析后参数的 `argv` 对象。
- **示例：构建 `new` 命令**

  ```jsx
  .command('new <note>', '创建一个新笔记', (yargs) => {
      // Builder 函数：配置 'new' 命令的参数和选项
      return yargs
          .positional('note', {
              type: 'string',
              description: '要创建的笔记内容'
          })
          .option('tags', {
              alias: 't',         // 别名，可以使用 -t
              type: 'string',
              description: '为笔记添加标签'
          });
  }, (argv) => {
      // Handler 函数：处理 'new' 命令的逻辑
      // 之后我们会在这里实现保存笔记的逻辑
      console.log('笔记内容:', argv.note);
      console.log('标签:', argv.tags);
  })

  ```

- **位置参数 (Positional Arguments) vs. 选项 (Options/Flags)**
  - **位置参数**: 命令后面直接跟的值，如 `note new "我的笔记"` 中的 `"我的笔记"`。
  - **选项**: 以 `-` 或 开头的键值对，如 `note new "..." --tags="work,urgent"`。它们可以有别名 (`alias`)。
- **笔记应用所需的所有命令**
  - `new <note>`: 创建一条新笔记。
  - `all`: 列出所有笔记。
  - `find <filter>`: 根据关键词查找笔记。
  - `remove <id>`: 根据 ID 删除一条笔记。
  - `web [port]`: 启动一个 Web 服务器来查看笔记，端口是可选的。
  - `clean`: 清空所有笔记。
- **验证设置**
  - 在定义完所有命令后，可以在终端运行 `note --help`。
  - `yargs` 会自动生成一个格式精美的帮助文档，清晰地列出所有可用的命令、它们的参数、选项和描述。

# 14-async-code

- **数据持久化策略**
  - 在真实的应用中，数据通常存储在数据库中。
  - 在本课程中，为了简化，我们将使用一个**文件 (`db.json`)** 作为我们的“数据库”来持久化存储笔记数据。
- **理解异步 (Asynchronous) JavaScript**
  - 在 Node.js 中，异步编程比在客户端 JavaScript 中更常见、更重要。
  - **核心概念**: 异步代码的执行顺序**不一定**与它被编写的顺序一致。Node.js 通过**调度**任务在稍后执行来实现并行处理（并发），而不是真正地在同一时刻执行多个任务（并行，这需要多线程/多进程）。
  - **主要触发异步的场景** (99%的情况):
    1. **网络操作**: 发起 HTTP 请求、与外部 API 通信。
    2. **文件系统/存储操作**: 读取/写入文件、与数据库交互。
    3. **定时器**: 使用 `setTimeout`, `setInterval` 等。
- **处理异步的三种方式 (演进过程)**
  1. **回调函数 (Callbacks)**
     - 最早的处理方式。将一个函数作为参数传递给另一个函数，当异步操作完成时，这个回调函数会被执行。
     - **问题**: 当多个异步操作相互依赖时，容易产生“**回调地狱** (Callback Hell)”——代码层层嵌套，形成金字塔形状，难以阅读和维护。
     - **注意**: 并非所有使用回调的函数都是异步的。例如，数组的 `map`, `forEach` 方法接受回调，但它们是**同步**的，因为不涉及网络、文件或定时器。
  2. **Promises (承诺)**
     - 为了解决回调地狱而引入的模式。一个 Promise 对象代表一个尚未完成但最终会完成的异步操作。
     - 使用 `.then()` 方法来处理成功的结果，`.catch()` 处理错误。
     - **优点**: 允许链式调用（`.then().then()...`），将嵌套的代码结构拉平，使得代码在视觉上更清晰，始终保持一层嵌套。
     - 你可以手动将一个基于回调的函数“Promise 化”（promisify）。
  3. **`async/await`**
     - 这是建立在 Promises 之上的“语法糖”，是目前处理异步操作的**最佳实践和首选方法**。
     - **工作方式**:
       - `async`: 标记一个函数是异步的，这个函数会自动返回一个 Promise。
       - `await`: 只能在 `async` 函数内部使用，它会“暂停”函数的执行，等待一个 Promise 完成，然后返回その结果。
     - **优点**: 它让异步代码看起来和写起来都像**同步代码**，从上到下顺序执行，非常直观，易于理解和调试。
     - **Top-Level Await**: 在最新版本的 Node.js 中，你可以在文件的顶层直接使用 `await`，而无需将其包裹在 `async` 函数中，这极大地简化了脚本编写。

# 15-fs-module

- **`fs` 模块简介**
  - `fs` 是 Node.js 的内置核心模块，代表 **File System** (文件系统)。
  - 它提供了一套 API，让你的程序能够以编程方式与计算机的文件系统进行交互，执行如读、写、创建、删除文件或目录等操作。
- **常用 `fs` 方法**
  - `fs.mkdir()`: 创建目录 (文件夹)。
  - `fs.readdir()`: 读取目录内容。
  - `fs.stat()`: 获取文件或目录的元信息 (如大小、创建时间)。
  - `fs.unlink()`: 删除文件。
  - `fs.rename()`: 重命名文件。
  - `fs.readFile()`: 读取文件内容。
  - `fs.writeFile()`: 写入文件内容。
- **`fs` 模块的 Promise 版本**
  - `fs` 模块的原始 API 是基于回调的，为了更方便地使用 `async/await`，Node.js 提供了一个 Promise 化的版本。
  - **导入方式**:
    ```jsx
    import fs from "node:fs/promises";
    ```
  - 这样导入后，所有 `fs` 的方法（如 `readFile`, `writeFile`）都会返回 Promise，可以直接配合 `await` 使用。
- **处理文件路径**
  - 在使用 ES Modules (`"type": "module"`) 时，传统的全局变量 `__dirname` 和 `__filename` 是不可用的。
  - 为了构造一个指向项目文件的绝对路径，你需要使用 `import.meta.url` 和 `URL` 对象。
    ```jsx
    // 构造指向 'package.json' 的路径
    const filePath = new URL("../package.json", import.meta.url);
    ```
- **代码示例: 读写文件**

  ```jsx
  import fs from "node:fs/promises";
  import { URL } from "node:url"; // 确保导入 URL 类

  async function operateOnFiles() {
    // --- 读取文件 ---
    const packageJsonPath = new URL("../package.json", import.meta.url);
    // 'utf-8' 编码告诉 readFile 将二进制数据解码为人类可读的文本
    const content = await fs.readFile(packageJsonPath, "utf8");
    const packageJson = JSON.parse(content);
    console.log("读取到的包名:", packageJson.name);

    // --- 写入文件 ---
    const newFilePath = new URL("../demo.js", import.meta.url);
    const scriptContent = "console.log('Hello from the new file!');";
    await fs.writeFile(newFilePath, scriptContent);
    console.log("文件写入成功!");
  }

  operateOnFiles();
  ```

- **调试技巧**
  - 对于复杂的异步流程或回调地狱，简单的 `console.log` 是一个非常有效的调试工具。
  - **调试流程**:
    1. 从最内层的函数调用开始。
    2. 在每个异步操作前后添加日志，打印出变量的值。
    3. 将实际输出与你的预期进行比较。通常问题在于你告诉计算机做的事情和你以为你告诉它做的事情之间有偏差。
    4. 在编写不熟悉的代码时，养成“写一点，测一点”的习惯，确保每一步都符合预期，避免问题累积。

# 16-using-a-file-as-a-db

- **目标: 创建一个文件作为我们的数据库**
  - 我们将创建一个 `db.json` 文件来持久化存储我们的笔记数据。
  - 同时，我们会创建一个 `db.js` 模块，封装所有与这个文件交互的底层逻辑，为上层应用提供一个简洁的 API。
- **步骤 1: 创建 `db.json` 文件**
  - 在项目的**根目录**下创建一个名为 `db.json` 的文件。
  - 初始化内容如下，定义一个 `notes` 数组来存放所有笔记：
    ```json
    {
      "notes": []
    }
    ```
- **步骤 2: 创建数据库交互模块 (`src/db.js`)**

  - 这个模块将作为我们自制的“ORM”(对象关系映射)或“SDK”，负责所有底层的读写操作。
  - **导入依赖并设置路径**:

    ```jsx
    import fs from "node:fs/promises";
    import { URL } from "node:url";

    // 构造到 db.json 的绝对路径
    const DB_PATH = new URL("../db.json", import.meta.url);
    ```

  - **创建核心工具函数**:

    1. **`getDB()`: 读取并解析整个数据库文件。**

       ```jsx
       export const getDB = async () => {
         const db = await fs.readFile(DB_PATH, "utf-8");
         return JSON.parse(db);
       };
       ```

    2. **`saveDB(db)`: 将一个 JavaScript 对象转换成 JSON 字符串，并覆盖写入到数据库文件。**

       ```jsx
       export const saveDB = async (db) => {
         await fs.writeFile(DB_PATH, JSON.stringify(db, null, 2));
         return db;
       };
       ```

       - `JSON.stringify` 的后两个参数 `(null, 2)` 用于格式化输出的 JSON，使其带有缩进，更易于阅读。

    3. **`insertDB(note)`: 插入一条新笔记。**

       - 这需要先**读取**整个数据库，**修改** `notes` 数组，然后再**保存**回去。
       - 这是一个“读-改-写”的原子操作。

       ```jsx
       export const insertDB = async (note) => {
         const db = await getDB();
         db.notes.push(note);
         await saveDB(db);
         return note;
       };
       ```

- **抽象的意义**
  - 我们将文件系统的底层操作 (`fs` 模块) 封装在了 `db.js` 中。
  - 上层应用（如我们的命令处理逻辑）**不应**直接调用 `fs.readFile` 或 `fs.writeFile`，而应只使用 `getDB`, `saveDB`, `insertDB` 这些更高级、更具业务含义的函数。
  - 这种分层设计使得代码更清晰、更易于维护，并且未来如果想把数据存储从文件切换到真正的数据库（如 MySQL），我们只需要修改 `db.js` 这个模块，而上层应用代码无需改动。

# 17-crud-methods-create

- **为什么需要另一层抽象？**
  - `db.js` 模块提供了与**整个数据库文件**交互的通用方法（如 `getDB`, `saveDB`）。
  - 但我们的应用逻辑是围绕**笔记(Notes)**进行的。
  - 为了保持 `db.js` 的通用性（将来可能添加 `users` 等其他数据），我们将创建一个新的 `notes.js` 模块，专门封装所有与笔记相关的 **CRUD** 操作。
- **什么是 CRUD?**
  - **C**reate (创建)
  - **R**ead (读取)
  - **U**pdate (更新)
  - **D**elete (删除)
  - 这四个操作构成了绝大多数应用程序的核心功能。
- **步骤 1: 创建 `src/notes.js` 模块**
  - 这个模块将是我们业务逻辑的核心，它会使用 `db.js` 提供的底层方法来实现具体功能。
  - **导入依赖**:
    ```jsx
    import { getDB, saveDB, insertDB } from "./db.js";
    ```
- **步骤 2: 实现创建 (Create) 和读取 (Read) 方法**

  1. **`newNote(noteContent, tags)`: 创建一条新笔记。**

     - 它接收笔记内容和标签。
     - 构造一个包含 `id`, `content`, `tags` 的新笔记对象。
     - 调用 `insertDB` 将这个新笔记对象插入数据库。

     ```jsx
     export const newNote = async (noteContent, tags) => {
       const newNote = {
         content: noteContent,
         id: Date.now(), // 使用时间戳作为唯一 ID
         tags: tags || [], // 如果没有提供标签，则默认为空数组
       };
       await insertDB(newNote);
       return newNote;
     };
     ```

  2. **`getAllNotes()`: 获取所有笔记。**

     - 调用 `getDB` 获取整个数据库对象。
     - 使用**对象解构**只返回 `notes` 数组。

     ```jsx
     export const getAllNotes = async () => {
       const { notes } = await getDB();
       return notes;
     };
     ```

- **对象解构 (Destructuring) 快速回顾**
  - 这是一种从对象或数组中提取值的便捷语法。
  - **对象解构**:
    ```jsx
    const data = { shooting: 99, dribbling: 50 };
    const { shooting, dribbling } = data; // 创建了两个新变量: shooting 和 dribbling
    // 等同于: const shooting = data.shooting; const dribbling = data.dribbling;
    ```
  - **数组解构**:
    ```jsx
    const nums = [10, 20, 30];
    const [first, second] = nums; // first 为 10, second 为 20
    ```
  - 你也可以在**函数参数**中直接使用解构，这非常常用。
    ```jsx
    function printPlayer({ shooting }) {
      console.log(shooting);
    }
    printPlayer({ shooting: 99, dribbling: 50 }); // 输出 99
    ```

# 18-crud-methods-read-delete

- **目标: 在 `notes.js` 中继续实现读取和删除的逻辑**
- **`findNotes(filter)`: 查找笔记 (Read)**
  - 这个方法实现一个简单的全文搜索功能。
  - **逻辑流程**:
    1. 调用 `getAllNotes()` 获取所有的笔记。
    2. 使用数组的 `filter` 方法遍历所有笔记。
    3. 对于每条笔记，将其 `content` 和搜索词 `filter` 都转换为小写，以实现**不区分大小写**的匹配。
    4. 使用字符串的 `includes()` 方法检查笔记内容是否包含搜索词。
    5. 返回所有匹配的笔记组成的数组。
  - **代码实现**:
    ```jsx
    export const findNotes = async (filter) => {
      const { notes } = await getDB(); // 获取所有笔记
      return notes.filter((note) =>
        note.content.toLowerCase().includes(filter.toLowerCase())
      );
    };
    ```
- **`removeNote(id)`: 删除单条笔记 (Delete)**

  - **逻辑流程**:
    1. 获取所有笔记。
    2. 使用 `find()` 检查是否存在具有给定 `id` 的笔记。
    3. 如果找到匹配项，则使用 `filter()` 创建一个**新**的笔记数组，其中不包含要删除的笔记。
       - 这是一个**不可变 (immutable)** 的操作，我们不直接修改原始数组，而是创建一个新的。
    4. 调用 `saveDB()` 将这个新的笔记数组写回数据库。
    5. 返回被删除的笔记的 `id`，表示操作成功。
    6. 如果未找到匹配项，默认返回 `undefined`。
  - **代码实现**:

    ```jsx
    export const removeNote = async (id) => {
      const { notes } = await getDB();
      const match = notes.find((note) => note.id === id);

      if (match) {
        const newNotes = notes.filter((note) => note.id !== id);
        await saveDB({ notes: newNotes });
        return id;
      }
    };
    ```

  - **注意**: 在比较 `id` 时，使用 `===` (严格相等) 是最佳实践。

- **`removeAllNotes()`: 删除所有笔记 (Delete)**
  - 这个方法最为简单。
  - **逻辑流程**:
    1. 调用 `saveDB()` 方法。
    2. 传入一个 `notes` 属性为空数组的对象，直接覆盖整个数据库。
  - **代码实现**:
    ```jsx
    export const removeAllNotes = () => {
      return saveDB({ notes: [] });
    };
    ```
  - **代码技巧**:
    - 这是一个单行箭头函数，可以省略 `{}` 和 `return` 关键字。
    - 因为 `removeAllNotes` 函数内部没有在 `saveDB` 之后执行其他 `await` 操作，所以可以不使用 `async/await`，直接返回 `saveDB` 返回的 Promise。

# 19-using-the-crud-methods

- **目标: 将 `notes.js` 中创建的 CRUD 方法集成到 `commands.js` 中**
  - 现在，我们将把之前定义的命令处理程序（Handlers）与实际的业务逻辑连接起来。
- **更新 `new` 命令**

  1. **导入**: 从 `./notes.js` 中导入 `newNote` 函数。
  2. **处理标签**: 从 `argv.tags` 获取的标签是一个字符串，需要将其分割成数组。
  3. **调用业务逻辑**: 调用 `newNote` 函数，并传入笔记内容和处理后的标签数组。
  4. **输出结果**: 打印新创建的笔记对象。

  ```jsx
  // in commands.js
  import { newNote, getAllNotes, findNotes, removeNote, removeAllNotes } from './notes.js';
  // ...
  .command('new <note>', '...', (yargs) => { /* builder... */ }, async (argv) => {
    const tags = argv.tags ? argv.tags.split(',') : [];
    const note = await newNote(argv.note, tags);
    console.log('新笔记已添加!', note);
  })

  ```

- **更新 `all` 命令**

  - 创建一个可复用的 `listNotes` 辅助函数来格式化并打印笔记列表。
  - **逻辑**: 调用 `getAllNotes()` 获取所有笔记，然后传递给 `listNotes` 进行显示。

  ```jsx
  const listNotes = (notes) => {
    notes.forEach(({ id, content, tags }) => {
      console.log("ID:", id);
      console.log("标签:", tags.join(", "));
      console.log("内容:", content);
      console.log("\\n"); // 添加换行符以分隔笔记
    });
  };

  // ... in 'all' command handler
  const notes = await getAllNotes();
  listNotes(notes);
  ```

- **更新 `find` 命令**
  - **逻辑**: 调用 `findNotes()` 并传入过滤条件 `argv.filter`，然后将返回的匹配结果用 `listNotes` 显示出来。
  ```jsx
  // ... in 'find' command handler
  const matches = await findNotes(argv.filter);
  listNotes(matches);
  ```
- **更新 `remove` 命令**
  - **逻辑**: 调用 `removeNote()` 并传入要删除的笔记 ID `argv.id`。根据返回结果判断是否删除成功。
  ```jsx
  // ... in 'remove' command handler
  const id = await removeNote(argv.id);
  if (id) {
    console.log("笔记已删除:", id);
  } else {
    console.log("未找到该 ID 的笔记。");
  }
  ```
- **更新 `clean` 命令**
  - **逻辑**: 直接调用 `removeAllNotes()` 清空数据库。
  ```jsx
  // ... in 'clean' command handler
  await removeAllNotes();
  console.log("数据库已清空!");
  ```
- **总结**
  - 经过这些更新，我们的 CLI 应用现在功能完备。
  - 我们成功地将**命令定义** (`yargs` in `commands.js`)、**业务逻辑** (`notes.js`) 和**数据持久化** (`db.js`) 清晰地分离开来。
  - 这种分层结构使得代码易于理解、维护和扩展。

# 20-types-of-tests

- **引言**
  - 测试是软件开发中至关重要的一环，尽管编写测试可能不那么有趣，但拥有测试却能带来巨大的好处。
- **测试的主要类型**
  1. **单元测试 (Unit Testing)**
     - **定义**: 针对代码中最小的可测试单元（通常是一个函数或一个模块）进行的测试。
     - **目的**: 验证该单元在隔离的环境下，对于给定的输入，是否能产生预期的输出。它不关心整个应用的流程。
  2. **集成测试 (Integration Testing)**
     - **定义**: 测试多个单元组合在一起时是否能协同工作。
     - **目的**: 检查不同模块或服务之间的交互是否正确。例如，测试一个完整的注册流程，这个流程可能涉及调用用户服务、数据库服务和邮件服务。
  3. **端到端测试 (End-to-End Testing / E2E)**
     - **定义**: 模拟真实用户的使用场景，从用户的角度测试整个应用程序的完整流程。
     - **目的**: 验证从用户界面（UI）的交互开始，到后端服务器处理，再到数据库操作，最后返回响应的整个链路是否通畅。
     - **特点**: 通常需要一个浏览器环境来模拟用户的点击、滚动等操作。
     - **无头浏览器 (Headless Browser)**: 是一种没有图形用户界面（GUI）的浏览器。它可以在后台运行，执行浏览器代码，非常适合在服务器或终端中进行自动化测试，因为它更快、更节省资源。
  4. **API 测试 (API Testing)**
     - **定义**: 专注于测试应用程序的 API 接口。
     - **目的**: 验证 API 是否能正确响应，不仅检查返回的数据（逻辑），还检查 HTTP 状态码、响应头等 API 协议层面的内容是否符合预期。
- **其他测试类型**
  - 还包括回归测试 (Regression Testing)、快照测试 (Snapshot Testing) 等多种类型。
  - 一个项目通常不会实现所有类型的测试，这取决于项目规模和团队的测试文化。
- **推荐资源**
  - Frontend Masters 提供了更多关于测试的深入课程，例如 Kent C. Dodds 的 JavaScript 测试课程和 Steve Kinney 的 Cypress 测试课程。

# 21-unit-testing-with-jest

- **测试框架: Jest**
  - Jest 是一个由 Facebook 创建的流行 JavaScript 测试框架。
  - 它借鉴了早期框架（如 Mocha, Jasmine）的优点，并集成了断言库、mocking 工具等，提供了一站式的测试体验。
  - Jest 不仅可以用于后端测试，也广泛用于前端测试。
- **设置测试环境**

  1. **创建 `tests` 目录**: 在项目根目录创建一个名为 `tests` 的文件夹。
  2. **创建测试文件**: 测试文件通常遵循命名约定，如 `notes.test.js`。Jest 会自动查找并运行文件名中包含 `.test.` 或 `.spec.` 的文件。
  3. **安装 Jest**: 将 Jest 作为开发依赖项安装。

     ```bash
     npm install jest --save-dev

     ```

     - **`devDependencies` vs. `dependencies`**:
       - `devDependencies`: 只在开发过程中需要的工具（如测试、打包、代码检查），不会被打包到最终的生产环境中。
       - `dependencies`: 应用程序在生产环境中运行时必须的库。

  4. **配置 `package.json`**: 在 `scripts` 对象中，修改 `test` 命令来运行 Jest。

     ```json
     "scripts": {
       "test": "jest"
     }

     ```

- **测试用例的基本结构**

  - **`test(description, callback)`**: 定义一个测试用例。
    - `description`: 一个描述测试目的的字符串。
    - `callback`: 包含测试逻辑的函数。
  - **`expect(value)`**: Jest 的断言函数，包裹你想要验证的值。
  - **匹配器 (Matchers)**: 链接在 `expect` 后面的方法，用于进行具体的比较，如 `.toBe()`, `.toEqual()`。

  ```jsx
  // 一个简单的加法函数
  const add = (a, b) => a + b;

  test("add 函数应该能正确计算两个数的和", () => {
    // 1. 调用被测试的函数
    const result = add(1, 2);
    // 2. 使用 expect 和匹配器进行断言
    expect(result).toBe(3);
  });
  ```

- **运行测试**
  - 在终端中运行 `npm test` 命令。
  - Jest 会执行所有找到的测试文件，并报告通过或失败的结果。
- **测试驱动开发 (TDD)**
  - 一种开发流程，又称“红-绿-重构 (Red-Green-Refactor)”。
  1. **红 (Red)**: 首先编写一个描述预期功能的、会失败的测试。
  2. **绿 (Green)**: 编写最简单的代码来让测试通过。
  3. **重构 (Refactor)**: 在测试保持通过的前提下，优化和重构代码。
  - 虽然在实际工作中不总是严格遵循，但它是一种非常有价值的实践，尤其是在大型团队中。
- **代码覆盖率 (Code Coverage)**
  - 这是一个衡量你的测试覆盖了多少代码的指标。
  - 许多团队会设定一个最低的代码覆盖率阈值（如 80%），如果达不到，CI/CD 流程就会失败。

# 22-testing-with-mocks

- **核心概念: Mocking (模拟)**
  - **定义**: 在测试中，用一个“假的”或“存根 (stub)”实现来替换掉真实的依赖项（如数据库模块、API 调用等）。
  - **目的**: **隔离被测试单元**。当我们测试 `notes.js` 中的逻辑时，我们不希望它真的去读写文件系统。我们假设 `db.js` 模块是正常工作的，我们只想验证 `notes.js` 是否正确地调用了它。
  - **Spy (间谍)**: 一个被 mock 的函数通常也是一个“Spy”。它能记录自身被调用的情况，比如被调用了多少次、接收了什么参数等。这让我们可以进行类似 `expect(mockedFunction).toHaveBeenCalledWith('some-argument')` 这样的断言。
- **在 Jest 中使用 Mock**
  - **`beforeEach(callback)`**: 这是一个生命周期钩子函数，它会在当前文件中的**每一个**测试用例运行之前执行。
  - **作用**: 用于重置状态，确保每个测试都是独立的。一个常见的用途是在每个测试前调用 `jest.clearAllMocks()` 来清除所有 mock 函数的调用记录，防止测试之间相互干扰。
- **ES Modules 环境下的 Mocking (关键且复杂)**

  - 由于 ES Modules 是静态的（在编译时确定依赖），而 mocking 是动态的（在运行时替换），Jest 对 ESM 的 mock 支持比较新，语法也更复杂。

  1. **`jest.unstable_mockModule(modulePath, factory)`**: 这是在 ESM 环境下 mock 模块的方法。
  2. **动态导入 `await import(...)`**: 你必须在**调用 `jest.unstable_mockModule` 之后**，再使用动态 `import()` 来导入你想要测试的模块。这是因为 mock 必须在模块被首次加载前完成设置。
  3. **配置 `package.json`**: 为了让 Jest 能正确处理 ESM，需要更新 `test` 脚本，添加 Node.js 的实验性标志。

     ```json
     "scripts": {
       "test": "node --experimental-vm-modules node_modules/jest/bin/jest.js"
     }

     ```

- **测试 `newNote` 函数的示例**

  ```jsx
  import { jest } from "@jest/globals"; // 导入 Jest 全局变量

  // 1. 在所有测试之前 mock db.js 模块
  jest.unstable_mockModule("../src/db.js", () => ({
    insertDB: jest.fn(), // 将 insertDB mock 成一个 jest 函数
    getDB: jest.fn(),
  }));

  // 2. 动态导入被 mock 的模块和要测试的模块
  const { insertDB } = await import("../src/db.js");
  const { newNote } = await import("../src/notes.js");

  // 3. 在每个测试前清除 mock 记录
  beforeEach(() => {
    insertDB.mockClear();
  });

  test("newNote 应该插入数据并返回它", async () => {
    const noteContent = "测试笔记";
    const noteTags = ["test"];

    // 调用 newNote
    const result = await newNote(noteContent, noteTags);

    // 断言：内容和标签应该匹配
    expect(result.content).toBe(noteContent);
    expect(result.tags).toEqual(noteTags); // 使用 toEqual 比较数组
  });
  ```

- **对象和数组的比较**
  - `.toBe()`: 使用 `===` 进行严格相等比较，不适用于对象或数组，因为它们是引用类型。
  - `.toEqual()`: 进行“深层”比较，递归地检查对象的所有属性或数组的所有元素是否相等。**在比较对象或数组时，应使用 `.toEqual()`**。

# 23-additional-test-examples

- **测试 `getAllNotes` 函数**
  - **策略**:
    1. Mock `getDB` 函数，使其在被调用时返回一个预设的、包含笔记的数据库对象。
    2. 调用 `getAllNotes`。
    3. 断言 `getAllNotes` 返回的笔记数组与我们预设的笔记数组内容相同 (`.toEqual()`)。
- **测试 `removeNote` 函数 (边缘情况)**
  - **策略**:
    1. Mock `getDB` 返回一个已知的数据库状态。
    2. 调用 `removeNote` 并传入一个**不存在的** ID。
    3. 断言 `removeNote` 的返回值是 `undefined`，因为没有找到匹配的笔记可以删除。
- **使用 `describe` 组织测试**

  - **`describe(name, fn)`**: Jest 提供的一个全局函数，用于将相关的测试用例分组。
  - **好处**:
    - 在测试报告中，测试会以分组的形式展现，结构更清晰。
    - 方便对一组测试应用共同的设置，例如在 `describe` 块内部使用 `beforeEach`。

  ```jsx
  describe("CLI App - Note Functions", () => {
    // 可以在这里放一个 beforeEach，它只作用于这个 describe 块

    test("newNote 应该能创建笔记", () => {
      // ...
    });

    test("getAllNotes 应该能获取所有笔记", () => {
      // ...
    });
  });
  ```

- **`it` 是 `test` 的别名**
  - 在 Jest 中，你可以使用 `it` 来代替 `test`，它们的功能完全相同。
  - `it('should do something...', () => { ... });`
  - 这是一种风格选择，源自于**行为驱动开发 (BDD)** 的理念，旨在让测试描述读起来更像一句通顺的英文句子。

# 24-creating-a-basic-server

- **回顾与展望**
  - 至此，我们已经学习了构建 CLI、操作文件系统和异步编程。仅用这些知识就可以构建很多强大的工具，例如打包工具 (Webpack, Vite)、代码检查工具 (Linters) 等。
  - 接下来，我们将探讨 Node.js 最常见的应用场景：**创建服务器**。
- **什么是服务器？**
  - 在 Node.js 的上下文中，服务器就是一个**持续运行的程序**，它**监听网络请求**并返回**响应**。
  - 它可以响应各种数据类型，如 HTML, JSON, CSS, 图片, 视频流等。
- **使用 Node.js 内置的 `http` 模块创建服务器**

  1. **导入模块**:

     ```jsx
     import http from "node:http";
     ```

  2. **创建服务器实例**:

     - 使用 `http.createServer()` 方法，它接收一个回调函数作为参数。
     - 这个回调函数会在每次接收到请求时被执行。
     - 回调函数接收两个核心对象：`req` (请求对象) 和 `res` (响应对象)。

     ```jsx
     const server = http.createServer((req, res) => {
       // 处理请求和响应的逻辑写在这里
     });
     ```

- **处理响应 (`res` 对象)**
  - `res.statusCode = 200;`: 设置 HTTP 状态码。
    - **2xx**: 成功 (e.g., `200 OK`)
    - **3xx**: 重定向/缓存 (e.g., `301 Moved Permanently`)
    - **4xx**: 客户端错误 (e.g., `404 Not Found`, `401 Unauthorized`)
    - **5xx**: 服务器端错误 (e.g., `500 Internal Server Error`)
  - `res.setHeader('Content-Type', 'text/plain');`: 设置响应头。`Content-Type` 告诉浏览器服务器返回的是什么类型的数据（MIME 类型）。
  - `res.end('Hello there');`: 发送响应体内容，并结束本次响应。这是必须的步骤。
- **启动服务器**
  - `server.listen(port, callback)`: 让服务器在一个指定的**端口 (port)** 上开始监听。
  - **端口**: 是一个数字，用于区分同一台机器上的不同网络服务。常见的开发端口有 3000, 4000, 8080 等。
  - `localhost`: 是一个特殊的主机名，代表“本机”。
- **完整示例**:

  ```jsx
  import http from "node:http";

  const port = 4000;

  const server = http.createServer((req, res) => {
    res.statusCode = 200;
    res.setHeader("Content-Type", "text/plain");
    res.end("Hello there");
  });

  server.listen(port, () => {
    console.log(`服务器正在 <http://localhost>:${port}/ 上运行`);
  });
  ```

- **重要特性**
  - 与之前的脚本不同，服务器启动后**进程不会自动退出**。它会一直运行，等待并处理新的请求，直到你手动停止它（例如，在终端按 `Ctrl+C`）。

# 25-interpolating-data-formatting-notes

- **目标: 创建一个网页来展示我们的笔记**
  - 我们将创建一个服务器，它能从 `db.json` 读取数据，然后将这些数据动态地渲染到一个 HTML 页面上，并发送给浏览器。
- **核心概念: 数据插值 (Interpolation)**
  - **定义**: 将动态数据嵌入到静态模板中的过程。
  - **示例**: 在一个字符串模板 `"Hello, {{ name }}!"` 中，用一个真实的名字（如 "Scott"）替换掉 `{{ name }}` 这个占位符。
- **步骤 1: 创建 HTML 模板 (`src/template.html`)**
  - 这是一个基础的 HTML 文件，其中包含一个特殊的占位符，用来标记动态内容将被插入的位置。
  ```html
  <!DOCTYPE html>
  <html>
    <head>
      <title>我的笔记</title>
    </head>
    <body>
      <h1>所有笔记</h1>
      <div class="notes">{{ notes }}</div>
    </body>
  </html>
  ```
- **步骤 2: 安装 `open` 包**

  - `open` 是一个方便的工具库，可以在代码中自动用用户的默认浏览器打开一个指定的 URL。
  - 这在开发中非常有用，可以省去手动复制粘贴地址的步骤。

  ```bash
  npm install open

  ```

- **步骤 3: 编写数据处理函数 (`src/server.js`)**

  1. **`interpolate(template, data)` 函数**:
     - 接收一个 HTML 模板字符串和一个包含数据的对象。
     - 使用正则表达式查找模板中所有 `{{ key }}` 形式的占位符。
     - 将每个占位符替换为 `data` 对象中对应 `key` 的值。
  2. **`formatNotes(notes)` 函数**:

     - 接收从数据库中读取的笔记对象数组。
     - 使用 `Array.prototype.map()` 方法遍历这个数组。
     - 对于每一个笔记对象，它会生成一段代表该笔记的 HTML 字符串。
     - 最后，使用 `Array.prototype.join('')` 将所有 HTML 片段连接成一个大的 HTML 字符串。

     ```jsx
     // 简化版示例
     const formatNotes = (notes) => {
       return notes
         .map(
           (note) => `
         <div class="note">
           <p>${note.content}</p>
           <div class="tags">
             ${note.tags
               .map((tag) => `<span class="tag">${tag}</span>`)
               .join("")}
           </div>
         </div>
       `
         )
         .join("");
     };
     ```

     - 这个过程本质上就是服务器端渲染 (Server-Side Rendering, SSR) 的核心思想，类似于 React 或 Vue 在服务器上做的事情。

# 26-sending-notes-to-the-client

- **目标: 组合所有部分，完成服务器逻辑并与 CLI 集成**
- **`createServer(notes)` 函数**
  - 这是一个工厂函数，接收笔记数据并返回一个配置好的 HTTP 服务器实例。
  - **工作流程**:
    1. 在每次请求时，异步读取 `template.html` 文件的内容。
    2. 调用 `formatNotes(notes)` 将笔记数组转换为 HTML 字符串。
    3. 调用 `interpolate()` 函数，将格式化后的笔记 HTML 注入到模板中，生成最终的完整 HTML 页面。
    4. 设置响应头，特别是 `Content-Type: 'text/html'`，告诉浏览器这是一个 HTML 文档。
    5. 使用 `res.end(html)` 将最终的 HTML 发送给客户端。
- **`start(notes, port)` 函数**
  - 这是启动服务器的入口函数。
  - **工作流程**:
    1. 调用 `createServer(notes)` 创建服务器。
    2. 让服务器在指定的 `port` 上开始监听。
    3. 在 `listen` 的回调函数中（表示服务器已成功启动）：
       - 打印服务器的地址到控制台。
       - 调用 `open()` 函数，自动在浏览器中打开该地址。
  - 这个函数被导出，以便在其他模块（如 `commands.js`）中调用。
- **模块化与封装**
  - 在 `server.js` 中，只有 `start` 函数被导出了。
  - `createServer`, `formatNotes`, `interpolate` 等函数都是该模块的内部实现细节，对外部是不可见的。
  - 这就是模块化的好处：**封装实现，只暴露公共 API**。这使得代码更易于管理和维护。
- **更新 `web` 命令 (`commands.js`)**

  - **逻辑**:
    1. 从 `./notes.js` 导入 `getAllNotes`，从 `./server.js` 导入 `start`。
    2. 在 `web` 命令的处理程序中：
       a. `await getAllNotes()` 从数据库获取所有笔记数据。
       b. 调用 `start(notes, argv.port)`，将数据和端口号传递给服务器启动函数。

  ```jsx
  // in commands.js
  .command('web [port]', '启动 Web 服务器', /*...*/ async (argv) => {
      const notes = await getAllNotes();
      start(notes, argv.port);
  });

  ```

- **运行和结果**
  - 首先，使用 `note new "..."` 添加一些笔记。
  - 然后运行 `note web`。
  - 终端会显示服务器已启动，并且会自动打开一个浏览器窗口，页面上会显示所有你添加的笔记。
  - 这就是**服务器端渲染 (Server-Side Rendering, SSR)** 的一个完整示例。
- **关于 `http` vs. `Express`**
  - 直接使用 Node.js 内置的 `http` 模块来构建复杂的服务器是可行的，但很繁琐。
  - 在实际项目中，开发者通常会使用像 **Express.js** 这样的框架，它在 `http` 模块之上提供了更高级、更方便的 API 来处理路由、中间件等。

# 27-wrapping-up

- **课程项目回顾**
  - 我们从头构建了一个功能完整的应用，涵盖了：
    1. **命令行界面 (CLI)**: 使用 `yargs` 创建了一个可以进行增删改查 (CRUD) 操作的笔记工具。
    2. **数据持久化**: 使用 `fs` 文件系统模块，将 `db.json` 文件作为我们的数据库。
    3. **模块化**: 学习了如何组织代码，创建和使用内置、第三方和自定义模块。
    4. **异步编程**: 掌握了处理异步操作的演进，从回调到 Promises，再到 `async/await`。
    5. **测试**: 使用 `Jest` 对我们的业务逻辑进行了单元测试，并学习了 `mocking` 的概念。
    6. **Web 服务器**: 使用 Node.js 内置的 `http` 模块创建了一个简单的服务器，实现了服务器端渲染 (SSR) 来展示笔记。
- **核心理念**
  - 绝大多数 Web 应用的本质都是：**从数据源（数据库）拉取数据，将其插入（插值）到一个模板中（HTML/JS），然后发送给客户端**。
  - 所有的现代框架（如 React, Vue, Svelte）都是对这个核心流程的抽象和优化。理解了这个基础，学习任何新框架都会变得更容易。
- **后续学习建议 (Next Steps)**
  1. **学习 Web 框架**:
     - **Express.js**: Node.js 社区最经典、资源最丰富的后端框架，是学习构建 API 的绝佳起点。
  2. **使用真实数据库**:
     - 尝试将文件数据库替换为 **PostgreSQL** 或 **MongoDB**。
  3. **学习 ORM/查询构建器**:
     - **Prisma**: 一个现代化的、类型安全的数据库工具集，强烈推荐。它能极大地简化与数据库的交互。
  4. **发布 NPM 包**:
     - 尝试将你创建的工具（甚至就是这个笔记应用）发布到 NPM。这是一个很好的实践，能让你了解包发布的完整流程。
  5. **掌握 TypeScript**:
     - 在现代 JavaScript 开发中，TypeScript 几乎是必备技能。
  6. **学习部署 (Deployment)**:
     - 将你的服务器应用部署到云平台，如 Vercel, AWS, DigitalOcean 等。让你的应用在真实的服务器上运行是至关重要的一步。
  7. **构建个人项目**:
     - 将所学知识应用到解决你个人生活中的问题上，创建一些小型自动化工具。
     - **示例**:
       - 编写一个脚本，使用无头浏览器定时检查某个网站（如球鞋网站）是否有货，并通过短信或邮件通知你。
       - 编写一个脚本，自动登录并支付你的每月账单。
